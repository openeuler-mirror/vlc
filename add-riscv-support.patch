diff --git a/configure.ac b/configure.ac
index d6e7535..b8dbdc1 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1638,6 +1638,28 @@ AS_IF([test "${enable_altivec}" = "yes"], [
 AC_SUBST(ALTIVEC_CFLAGS)
 AM_CONDITIONAL([HAVE_ALTIVEC], [test "$have_altivec" = "yes"])
 
+
+AC_ARG_ENABLE([rvv],
+  AS_HELP_STRING([--disable-rvv],
+    [disable RISC-V Vector extension (default auto)]),, [
+  AS_CASE([${host_cpu}], [riscv*], [enable_rvv="yes"], [enable_rvv="no"])
+])
+AS_IF([test "${enable_rvv}" != "no"], [
+  AC_CACHE_CHECK([if $CCAS groks RISC-V V assembly], [ac_cv_riscv_v], [
+    AC_COMPILE_IFELSE([
+      AC_LANG_PROGRAM(,[[
+asm volatile(".option arch, +v\nvsetvli x0, x0, e8");
+]])
+    ], [
+      ac_cv_riscv_v="yes"
+    ], [
+      ac_cv_riscv_v="no"
+    ])
+  ])
+])
+AM_CONDITIONAL([HAVE_RVV], [test "${ac_cv_riscv_v}" = "yes"])
+
+
 dnl
 dnl  Memory usage
 dnl
diff --git a/contrib/src/ffmpeg/rules.mak b/contrib/src/ffmpeg/rules.mak
index 27fd9b8..4249ff6 100644
--- a/contrib/src/ffmpeg/rules.mak
+++ b/contrib/src/ffmpeg/rules.mak
@@ -122,6 +122,11 @@ ifeq ($(ARCH),mips64el)
 FFMPEGCONF += --arch=mips64
 endif
 
+# RISC-V stuff
+ifneq ($(findstring $(ARCH),riscv32 riscv64),)
+FFMPEGCONF += --arch=riscv
+endif
+
 # x86 stuff
 ifeq ($(ARCH),i386)
 ifndef HAVE_DARWIN_OS
diff --git a/contrib/src/gpg-error/lock-obj-pub.posix.h b/contrib/src/gpg-error/lock-obj-pub.posix.h
new file mode 100644
index 0000000..febc7a6
--- /dev/null
+++ b/contrib/src/gpg-error/lock-obj-pub.posix.h
@@ -0,0 +1,18 @@
+## lock-obj-pub.posix.h
+## File created by Rémi Denis-Courmont - DO EDIT
+## To be included by mkheader into gpg-error.h
+
+#include <pthread.h>
+
+typedef struct
+{
+  long vers;
+  union {
+    pthread_mutex_t mtx;
+    /* In theory, pointers could have a higher alignment than pthread_mutex_t,
+     * so keep in the union to match _gpgrt_lock_t. */
+    long *alignme;
+  } u;
+} gpgrt_lock_t;
+
+#define GPGRT_LOCK_INITIALIZER { 1, { PTHREAD_MUTEX_INITIALIZER } }
\ No newline at end of file
diff --git a/contrib/src/gpg-error/rules.mak b/contrib/src/gpg-error/rules.mak
index 6a3e874..797804f 100644
--- a/contrib/src/gpg-error/rules.mak
+++ b/contrib/src/gpg-error/rules.mak
@@ -24,15 +24,11 @@ endif
 	$(APPLY) $(SRC)/gpg-error/win32-unicode.patch
 	$(APPLY) $(SRC)/gpg-error/version-bump-gawk-5.patch
 	$(APPLY) $(SRC)/gpg-error/win32-extern-struct.patch
-	$(MOVE)
-ifdef HAVE_ANDROID
-ifeq ($(ARCH),aarch64)
-	# x86_64-linux-gnu matches exactly what gets generated by gen-posix-lock-obj on arm64
-	cp $@/src/syscfg/lock-obj-pub.x86_64-pc-linux-gnu.h $@/src/syscfg/lock-obj-pub.linux-android.h
-else
-	cp $@/src/syscfg/lock-obj-pub.arm-unknown-linux-androideabi.h $@/src/syscfg/lock-obj-pub.linux-android.h
-endif
+ifndef HAVE_WIN32
+	cp -f -- "$(SRC)/gpg-error/lock-obj-pub.posix.h" \
+		"$(UNPACK_DIR)/src/lock-obj-pub.native.h"
 endif
+	$(MOVE)
 ifdef HAVE_TIZEN
 ifeq ($(TIZEN_ABI), x86)
 	cp $@/src/syscfg/lock-obj-pub.i686-pc-linux-gnu.h $@/src/syscfg/lock-obj-pub.linux-gnueabi.h
@@ -53,5 +49,6 @@ endif
 .gpg-error: libgpg-error
 	$(RECONF)
 	cd $< && $(HOSTVARS) ./configure $(HOSTCONF) --disable-nls --disable-shared --disable-languages --disable-tests
-	cd $< && $(MAKE) install
+	# pre_mkheader_cmds would delete our lock-obj-pub-native.h
+	cd $< && $(MAKE) pre_mkheader_cmds=true install
 	touch $@
diff --git a/contrib/src/main.mak b/contrib/src/main.mak
index ae52a06..9f27942 100644
--- a/contrib/src/main.mak
+++ b/contrib/src/main.mak
@@ -184,6 +184,10 @@ ifeq ($(call cppcheck, __SOFTFP__),)
 HAVE_FPU = 1
 endif
 endif
+else ifneq ($(filter riscv%, $(ARCH)),)
+ifneq ($(call cppcheck, __riscv_flen),)
+HAVE_FPU = 1
+endif
 else ifneq ($(call cppcheck, __mips_hard_float),)
 HAVE_FPU = 1
 endif
diff --git a/contrib/src/postproc/rules.mak b/contrib/src/postproc/rules.mak
index 080c322..93f33dd 100644
--- a/contrib/src/postproc/rules.mak
+++ b/contrib/src/postproc/rules.mak
@@ -50,6 +50,11 @@ ifeq ($(ARCH),mips64el)
 POSTPROCCONF += --arch=mips64
 endif
 
+# RISC-V stuff
+ifneq ($(findstring $(ARCH),riscv32 riscv64),)
+POSTPROCCONF += --arch=riscv
+endif
+
 # x86 stuff
 ifeq ($(ARCH),i386)
 POSTPROCCONF += --arch=x86
diff --git a/contrib/src/upnp/rules.mak b/contrib/src/upnp/rules.mak
index 8f0f385..6a6ea0f 100644
--- a/contrib/src/upnp/rules.mak
+++ b/contrib/src/upnp/rules.mak
@@ -55,5 +55,11 @@ endif
 .upnp: upnp
 	$(RECONF)
 	cd $< && $(HOSTVARS) CFLAGS="$(CFLAGS) -DUPNP_STATIC_LIB" ./configure --disable-samples --without-documentation $(CONFIGURE_ARGS) $(HOSTCONF)
+ifdef HAVE_LINUX
+ifndef HAVE_ANDROID
+	sed -e 's,^Libs\(.*\)-pthread,Libs\1-pthread -lpthread,' \
+		-i $</libupnp.pc
+endif
+endif
 	cd $< && $(MAKE) install
 	touch $@
diff --git a/include/vlc_cpu.h b/include/vlc_cpu.h
index b2f0f45..2f24a8d 100644
--- a/include/vlc_cpu.h
+++ b/include/vlc_cpu.h
@@ -179,6 +179,18 @@ VLC_API unsigned vlc_CPU(void);
 # elif defined (__mips_hard_float)
 #  define HAVE_FPU 1
 
+# elif defined (__riscv)
+#  ifdef __riscv_flen
+#   define HAVE_FPU 1
+#  endif
+#  define VLC_CPU_RV_V 0x1
+
+#  ifdef __riscv_v
+#   define vlc_CPU_RV_V() (1)
+#  else
+#   define vlc_CPU_RV_V() ((vlc_CPU() & VLC_CPU_RV_V) != 0)
+#  endif
+
 # else
 /**
  * Are single precision floating point operations "fast"?
diff --git a/modules/Makefile.am b/modules/Makefile.am
index 53b90a2..ee2d8df 100644
--- a/modules/Makefile.am
+++ b/modules/Makefile.am
@@ -43,6 +43,7 @@ include meta_engine/Makefile.am
 include misc/Makefile.am
 include notify/Makefile.am
 include packetizer/Makefile.am
+include riscv/Makefile.am
 include services_discovery/Makefile.am
 include spu/Makefile.am
 include stream_filter/Makefile.am
diff --git a/modules/riscv/Makefile.am b/modules/riscv/Makefile.am
new file mode 100644
index 0000000..74e0458
--- /dev/null
+++ b/modules/riscv/Makefile.am
@@ -0,0 +1,11 @@
+riscvdir = $(pluginsdir)/riscv
+
+libvolume_rvv_plugin_la_SOURCES = \
+    riscv/mixer.c \
+    riscv/rvv_amplify.S
+libvolume_rvv_plugin_la_LIBADD = $(AM_LIBADD) $(LIBM)
+
+if HAVE_RVV
+riscv_LTLIBRARIES = \
+	libvolume_rvv_plugin.la
+endif
\ No newline at end of file
diff --git a/modules/riscv/mixer.c b/modules/riscv/mixer.c
new file mode 100644
index 0000000..ef4c807
--- /dev/null
+++ b/modules/riscv/mixer.c
@@ -0,0 +1,134 @@
+/*****************************************************************************
+ * mixer.c: RISC-V V audio volume mixer module
+ *****************************************************************************
+ * Copyright (C) 2012, 2022 Rémi Denis-Courmont
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <assert.h>
+#include <math.h>
+#include <stdint.h>
+
+#include <vlc_common.h>
+#include <vlc_plugin.h>
+#include <vlc_cpu.h>
+#include <vlc_aout.h>
+#include <vlc_aout_volume.h>
+
+void rvv_amplify_f32(void *, const void *, size_t, float);
+void rvv_amplify_f64(void *, const void *, size_t, double);
+void rvv_amplify_i16(void *, const void *, size_t, uint16_t);
+void rvv_amplify_i32(void *, const void *, size_t, uint32_t);
+void rvv_amplify_u8(void *, const void *, size_t, uint8_t);
+
+static void AmplifyFloat(audio_volume_t *volume, block_t *block, float amp)
+{
+    void *buf = block->p_buffer;
+
+    if (amp != 1.f)
+        rvv_amplify_f32(buf, buf, block->i_buffer, amp);
+
+    (void) volume;
+}
+
+static void AmplifyDouble(audio_volume_t *volume, block_t *block, float amp)
+{
+    void *buf = block->p_buffer;
+
+    if (amp != 1.f)
+        rvv_amplify_f64(buf, buf, block->i_buffer, amp);
+
+    (void) volume;
+}
+
+static void AmplifyShort(audio_volume_t *volume, block_t *block, float amp)
+{
+    void *buf = block->p_buffer;
+    uint_fast16_t fixed_amp = lroundf(ldexpf(amp, 16));
+
+    if (amp != 1.f)
+        rvv_amplify_i16(buf, buf, block->i_buffer, fixed_amp);
+
+    (void) volume;
+}
+
+static void AmplifyInt(audio_volume_t *volume, block_t *block, float amp)
+{
+    void *buf = block->p_buffer;
+    uint_fast32_t fixed_amp = lroundf(ldexpf(amp, 32));
+
+    if (amp != 1.f)
+        rvv_amplify_i32(buf, buf, block->i_buffer, fixed_amp);
+
+    (void) volume;
+}
+
+static void AmplifyByte(audio_volume_t *volume, block_t *block, float amp)
+{
+    void *buf = block->p_buffer;
+    uint_fast8_t fixed_amp = lroundf(ldexpf(amp, 8));
+
+    if (amp != 1.f)
+        rvv_amplify_u8(buf, buf, block->i_buffer, fixed_amp);
+
+    (void) volume;
+}
+
+static int Probe(vlc_object_t *obj)
+{
+    audio_volume_t *volume = (audio_volume_t *)obj;
+
+    if (!vlc_CPU_RV_V())
+        return VLC_ENOTSUP;
+
+    switch (volume->format) {
+        case VLC_CODEC_FL32:
+            volume->amplify = AmplifyFloat;
+            break;
+
+        case VLC_CODEC_FL64:
+            volume->amplify = AmplifyDouble;
+            break;
+
+        case VLC_CODEC_S16N:
+            volume->amplify = AmplifyShort;
+            break;
+
+        case VLC_CODEC_S32N:
+            volume->amplify = AmplifyInt;
+            break;
+
+        case VLC_CODEC_U8:
+            volume->amplify = AmplifyByte;
+            break;
+
+        default:
+            return VLC_ENOTSUP;
+    }
+
+    return VLC_SUCCESS;
+}
+
+vlc_module_begin()
+    set_subcategory(SUBCAT_AUDIO_AFILTER)
+    set_description("RISC-V V optimisation for audio volume")
+    set_capability("audio volume", 20)
+    set_callback(Probe)
+vlc_module_end()
\ No newline at end of file
diff --git a/modules/riscv/rvv_amplify.S b/modules/riscv/rvv_amplify.S
new file mode 100644
index 0000000..06ed78b
--- /dev/null
+++ b/modules/riscv/rvv_amplify.S
@@ -0,0 +1,103 @@
+/*****************************************************************************
+ * amplify.S: RISC-V V software amplification
+ ******************************************************************************
+ * Copyright (C) 2022 Rémi Denis-Courmont
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+	.option	arch, +v
+	.text
+	.align 2
+
+	.globl	rvv_amplify_f32
+	.type	rvv_amplify_f32, %function
+rvv_amplify_f32:
+	srli	a2, a2, 2
+#if defined (__riscv_float_abi_soft)
+	fmv.w.x	fa0, a3
+#endif
+1:	vsetvli	t0, a2, e32, m8, ta, ma
+	slli	t1, t0, 2
+	vle32.v	v16, (a1)
+	add	a1, a1, t1
+	vfmul.vf	v16, v16, fa0
+	sub	a2, a2, t0
+	vse32.v	v16, (a0)
+	add	a0, a0, t1
+	bnez	a2, 1b
+	ret
+
+	.globl	rvv_amplify_f64
+	.type	rvv_amplify_f64, %function
+rvv_amplify_f64:
+	srli	a2, a2, 3
+#if defined (__riscv_float_abi_soft) || defined (__riscv_float_abi_single)
+	fmv.d.x	fa0, a3
+#endif
+1:	vsetvli	t0, a2, e64, m8, ta, ma
+	slli	t1, t0, 3
+	vle64.v	v16, (a1)
+	add	a1, a1, t1
+	vfmul.vf	v16, v16, fa0
+	sub	a2, a2, t0
+	vse64.v	v16, (a0)
+	add	a0, a0, t1
+	bnez	a2, 1b
+	ret
+
+	.globl	rvv_amplify_i16
+	.type	rvv_amplify_i16, %function
+rvv_amplify_i16:
+	srli	a2, a2, 1
+1:	vsetvli	t0, a2, e16, m8, ta, ma
+	slli	t1, t0, 1
+	vle16.v	v16, (a1)
+	add	a1, a1, t1
+	vmulhsu.vx	v16, v16, a3
+	sub	a2, a2, t0
+	vse16.v	v16, (a0)
+	add	a0, a0, t1
+	bnez	a2, 1b
+	ret
+
+	.globl	rvv_amplify_i32
+	.type	rvv_amplify_i32, %function
+rvv_amplify_i32:
+	srli	a2, a2, 2
+1:	vsetvli	t0, a2, e32, m8, ta, ma
+	slli	t1, t0, 2
+	vle32.v	v16, (a1)
+	add	a1, a1, t1
+	vmulhsu.vx	v16, v16, a3
+	sub	a2, a2, t0
+	vse32.v	v16, (a0)
+	add	a0, a0, t1
+	bnez	a2, 1b
+	ret
+
+	.globl	rvv_amplify_u8
+	.type	rvv_amplify_u8, %function
+rvv_amplify_u8:
+1:	vsetvli	t0, a2, e8, m8, ta, ma
+	vle8.v	v16, (a1)
+	add	a1, a1, t0
+	vmulhu.vx	v16, v16, a3
+	sub	a2, a2, t0
+	vse8.v	v16, (a0)
+	add	a0, a0, t0
+	bnez	a2, 1b
+	ret
+	
\ No newline at end of file
diff --git a/modules/video_filter/Makefile.am b/modules/video_filter/Makefile.am
index d1703a7..332e6de 100644
--- a/modules/video_filter/Makefile.am
+++ b/modules/video_filter/Makefile.am
@@ -134,8 +134,8 @@ libdeinterlace_plugin_la_SOURCES = \
 	video_filter/deinterlace/yadif.h video_filter/deinterlace/yadif_template.h \
 	video_filter/deinterlace/algo_phosphor.c video_filter/deinterlace/algo_phosphor.h \
 	video_filter/deinterlace/algo_ivtc.c video_filter/deinterlace/algo_ivtc.h
-# inline ASM doesn't build with -O0
-libdeinterlace_plugin_la_CFLAGS = $(AM_CFLAGS) -O2
+libdeinterlace_plugin_la_CPPFLAGS = $(AM_CPPFLAGS)
+libdeinterlace_plugin_la_CFLAGS = $(AM_CFLAGS)
 if HAVE_NEON
 libdeinterlace_plugin_la_SOURCES += video_filter/deinterlace/merge_arm.S
 libdeinterlace_plugin_la_CFLAGS += -DCAN_COMPILE_ARM
@@ -144,6 +144,10 @@ if HAVE_ARM64
 libdeinterlace_plugin_la_SOURCES += video_filter/deinterlace/merge_arm64.S
 libdeinterlace_plugin_la_CFLAGS += -DCAN_COMPILE_ARM64
 endif
+if HAVE_RVV
+libdeinterlace_plugin_la_SOURCES += video_filter/deinterlace/merge_rvv.S
+libdeinterlace_plugin_la_CFLAGS += -DCAN_COMPILE_RVV
+endif
 libdeinterlace_plugin_la_LIBADD = libdeinterlace_common.la
 video_filter_LTLIBRARIES += libdeinterlace_plugin.la
 
diff --git a/modules/video_filter/deinterlace/deinterlace.c b/modules/video_filter/deinterlace/deinterlace.c
index 3b53d13..d7c59eb 100644
--- a/modules/video_filter/deinterlace/deinterlace.c
+++ b/modules/video_filter/deinterlace/deinterlace.c
@@ -566,6 +566,11 @@ notsupp:
         p_sys->pf_merge = pixel_size == 1 ? merge8_armv6 : merge16_armv6;
     else
 #endif
+#if defined(CAN_COMPILE_RVV)
+    if( vlc_CPU_RV_V() )
+        p_sys->pf_merge = pixel_size == 1 ? merge8_rvv : merge16_rvv;
+    else
+#endif
 #if defined(CAN_COMPILE_ARM64)
     if( vlc_CPU_ARM64_NEON() )
         p_sys->pf_merge = pixel_size == 1 ? merge8_arm64_neon : merge16_arm64_neon;
diff --git a/modules/video_filter/deinterlace/merge.h b/modules/video_filter/deinterlace/merge.h
index 2b31e87..1c21599 100644
--- a/modules/video_filter/deinterlace/merge.h
+++ b/modules/video_filter/deinterlace/merge.h
@@ -181,6 +181,10 @@ void merge16_arm64_neon (void *, const void *, const void *, size_t);
 
 #endif
 
+#if defined(CAN_COMPILE_RVV)
+void merge8_rvv(void *, const void *, const void *, size_t);
+void merge16_rvv(void *, const void *, const void *, size_t);
+#endif
 /*****************************************************************************
  * EndMerge routines
  *****************************************************************************/
diff --git a/modules/video_filter/deinterlace/merge_rvv.S b/modules/video_filter/deinterlace/merge_rvv.S
new file mode 100644
index 0000000..090975d
--- /dev/null
+++ b/modules/video_filter/deinterlace/merge_rvv.S
@@ -0,0 +1,57 @@
+/******************************************************************************
+ * merge_rvv.S: RISC-V Vector mean
+ ******************************************************************************
+ * Copyright (C) 2022 Rémi Denis-Courmont
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+	.option arch, +v
+	.text
+	.align	2
+
+	.globl	merge8_rvv
+	.type	merge8_rvv, %function
+merge8_rvv:
+	csrwi	vxrm, 0
+1:	vsetvli	t0, a3, e8, m8, ta, ma
+	vle8.v	v16, (a1)
+	add	a1, a1, t0
+	vle8.v	v24, (a2)
+	add	a2, a2, t0
+	vaaddu.vv	v16, v16, v24
+	sub	a3, a3, t0
+	vse8.v	v16, (a0)
+	add	a0, a0, t0
+	bnez	a3, 1b
+	ret
+
+	.globl	merge16_rvv
+	.type	merge16_rvv, %function
+merge16_rvv:
+	csrwi	vxrm, 0
+	srli	a3, a3, 1
+1:	vsetvli	t0, a3, e16, m8, ta, ma
+	slli	t1, t0, 1
+	vle16.v	v16, (a1)
+	add	a1, a1, t1
+	vle16.v	v24, (a2)
+	add	a2, a2, t1
+	vaaddu.vv	v16, v16, v24
+	sub	a3, a3, t0
+	vse16.v	v16, (a0)
+	add	a0, a0, t1
+	bnez	a3, 1b
+	ret
\ No newline at end of file
diff --git a/src/linux/cpu.c b/src/linux/cpu.c
index 38fcce9..abf3bca 100644
--- a/src/linux/cpu.c
+++ b/src/linux/cpu.c
@@ -29,13 +29,74 @@
 
 #undef CPU_FLAGS
 #if defined (__arm__)
-# define CPU_FLAGS "Features\t:"
+# define CPU_FLAGS "Features"
 
 #elif defined (__i386__) || defined (__x86_64__)
-# define CPU_FLAGS "flags\t\t:"
+# define CPU_FLAGS "flags"
 
 #elif defined (__powerpc__) || defined (__powerpc64__)
-# define CPU_FLAGS "cpu\t\t:"
+# define CPU_FLAGS "cpu"
+
+#elif defined (__riscv)
+# include <vlc_strings.h>
+# define CPU_FLAGS "isa"
+
+static unsigned vlc_CPU_RV_isa_parse(const char *isa)
+{
+    unsigned caps = 0;
+    int c;
+
+    if (vlc_ascii_tolower((unsigned char)isa[0]) != 'r'
+     || vlc_ascii_tolower((unsigned char)isa[1]) != 'v')
+        return 0;
+
+    isa += 2;
+
+    if (strncmp(isa, "32", 2) == 0 || strncmp(isa, "64", 2) == 0)
+        isa += 2;
+    else if (strncmp(isa, "128", 3) == 0)
+        isa += 3;
+    else
+        return 0;
+
+    while ((c = vlc_ascii_tolower((unsigned char)*isa)) != '\0') {
+        size_t extlen = 1;
+
+        switch (c) {
+            case '_':
+                break;
+
+            case 'z':
+            case 's':
+            case 'h':
+            case 'x':
+                extlen = 1 + strcspn(isa + 1, "_");
+                break;
+
+            default:
+                if (((unsigned)(c - 'a')) > 'y')
+                    return 0;
+
+                while (isa[extlen] && ((unsigned)(isa[extlen] - '0')) < 10)
+                    extlen++;
+
+                if (vlc_ascii_tolower(isa[extlen]) == 'p') {
+                    extlen++;
+
+                    while (isa[extlen] && ((unsigned)(isa[extlen] - '0')) < 10)
+                        extlen++;
+                }
+        }
+
+        /* TODO: Zve extensions */
+        if (c == 'v')
+            caps |= VLC_CPU_RV_V;
+
+        isa += extlen;
+    }
+
+    return caps;
+}
 
 #endif
 
@@ -54,7 +115,7 @@ static void vlc_CPU_init (void)
 
     while (getline (&line, &linelen, info) != -1)
     {
-        char *p = line, *cap;
+        char *p, *cap;
         uint_fast32_t core_caps = 0;
 
 #if defined (__arm__)
@@ -65,6 +126,15 @@ static void vlc_CPU_init (void)
         if (strncmp (line, CPU_FLAGS, strlen (CPU_FLAGS)))
             continue;
 
+        p = line + strlen(CPU_FLAGS);
+        p += strspn(p, "\t");
+        if (*p != ':')
+            continue;
+
+#if defined (__riscv)
+        p += strspn(p, "\t ");
+        core_caps = vlc_CPU_RV_isa_parse(p);
+#else
         while ((cap = strsep (&p, " ")) != NULL)
         {
 #if defined (__arm__)
@@ -106,6 +176,7 @@ static void vlc_CPU_init (void)
                 core_caps |= VLC_CPU_ALTIVEC;
 #endif
         }
+#endif
 
         /* Take the intersection of capabilities of each processor */
         all_caps &= core_caps;
diff --git a/src/linux/thread.c b/src/linux/thread.c
index 20da296..b499581 100644
--- a/src/linux/thread.c
+++ b/src/linux/thread.c
@@ -47,10 +47,34 @@ unsigned long vlc_thread_id(void)
      return tid;
 }
 
+#if !defined __cplusplus
+#define static_assert _Static_assert
+#endif
+
 static int sys_futex(void *addr, int op, unsigned val,
                      const struct timespec *to, void *addr2, int val3)
 {
-    return syscall(__NR_futex, addr, op, val, to, addr2, val3);
+    /* The futex Linux kernel system call exists in two variants:
+     * - the original one for use with long time_t, which suffers from the
+     *   year 2038 problem on 32-bit architectures,
+     * - the "time64" one for use with 64-bit time_t, which lacks backward
+     *   binary compatibility with 32-bit long time_t on 32-bit architectures.
+     */
+    static_assert (sizeof (time_t) == sizeof (long) || sizeof (time_t) == 8,
+                   "Unrecognised time_t type definition");
+
+#if !defined (__NR_futex)
+    /* Recent 32-bit platforms (e.g. riscv32) only support 64-bit time_t. */
+    static_assert (sizeof (time_t) == 8, "Expected 64-bit time_t");
+    const long num = __NR_futex_time64;
+#elif !defined (__NR_futex_time64)
+    static_assert (sizeof (time_t) == sizeof (long), "Expected long time_t");
+    const long num = __NR_futex;
+#else
+    const long num = sizeof (time_t) == sizeof (long)
+                     ? __NR_futex : __NR_futex_time64;
+#endif
+    return syscall(num, addr, op, val, to, addr2, val3);
 }
 
 static int vlc_futex_wake(void *addr, int nr)
diff --git a/src/misc/cpu.c b/src/misc/cpu.c
index b1bd34f..61a3ea9 100644
--- a/src/misc/cpu.c
+++ b/src/misc/cpu.c
@@ -322,6 +322,10 @@ void vlc_CPU_dump (vlc_object_t *obj)
     if (vlc_CPU_ARM_NEON())
         vlc_memstream_puts(&stream, "ARM_NEON ");
 
+#elif defined (__riscv)
+    if (vlc_CPU_RV_V())
+        vlc_memstream_puts(&stream, "V ");
+
 #endif
 
 #if HAVE_FPU
